import { describe, it } from 'mocha'
import { expectToBeCloseToArrayArrayArray } from '../../stdlib/test/helper-functions.js'

import { triangulate, triangulateToUnique } from '../dist/index.js'

const rectangle = [
  [0.592, 0.953],
  [0.304, 2.394],
  [2.904, 2.201],
  [2.394, 0.232]
]

const rectangleOnGrid = [
  [0, 0],
  [0, 2],
  [2, 2],
  [2, 0]
]

describe('Rectangle', async () => {
  it(`should work for average polygons with no distance provided`, () => {
    const output = [
      [
        [0.592, 0.953],
        [0.304, 2.394],
        [2.904, 2.201]
      ],
      [
        [2.904, 2.201],
        [2.394, 0.232],
        [0.592, 0.953]
      ]
    ]

    expectToBeCloseToArrayArrayArray(triangulate([rectangle]), output)
  })

  it(`should work for average polygons with a distance provided`, () => {
    const output = [
      [
        [1.304, 1.232],
        [1.4655588463411926, 0.6034795070965593],
        [0.592, 0.953]
      ],
      [
        [0.592, 0.953],
        [0.3960147328390722, 1.933606840204503],
        [1.304, 1.232]
      ],
      [
        [1.304, 2.232],
        [2.3040000000000003, 1.232],
        [1.304, 1.232]
      ],
      [
        [1.304, 1.232],
        [2.3040000000000003, 1.232],
        [1.4655588463411926, 0.6034795070965593]
      ],
      [
        [0.3960147328390722, 1.933606840204503],
        [1.304, 2.232],
        [1.304, 1.232]
      ],
      [
        [2.3040000000000003, 1.232],
        [2.402519316054499, 0.2648912417868794],
        [1.4655588463411926, 0.6034795070965593]
      ],
      [
        [2.402519316054499, 0.2648912417868794],
        [2.394, 0.232],
        [1.4655588463411926, 0.6034795070965593]
      ],
      [
        [1.304, 2.232],
        [2.3040000000000003, 2.232],
        [2.3040000000000003, 1.232]
      ],
      [
        [0.304, 2.394],
        [1.3012562303117026, 2.3199729029037854],
        [1.304, 2.232]
      ],
      [
        [2.3040000000000003, 2.232],
        [2.6532596580272494, 1.2329456208934397],
        [2.3040000000000003, 1.232]
      ],
      [
        [2.3040000000000003, 1.232],
        [2.6532596580272494, 1.2329456208934397],
        [2.402519316054499, 0.2648912417868794]
      ],
      [
        [0.3960147328390722, 1.933606840204503],
        [0.304, 2.394],
        [1.304, 2.232]
      ],
      [
        [2.2985124606234053, 2.2459458058075707],
        [2.3040000000000003, 2.232],
        [1.304, 2.232]
      ],
      [
        [1.3012562303117026, 2.3199729029037854],
        [2.2985124606234053, 2.2459458058075707],
        [1.304, 2.232]
      ],
      [
        [2.2985124606234053, 2.2459458058075707],
        [2.904, 2.201],
        [2.3040000000000003, 2.232]
      ],
      [
        [2.3040000000000003, 2.232],
        [2.904, 2.201],
        [2.6532596580272494, 1.2329456208934397]
      ]
    ]

    // Keeping trace of the original output before applying the extra delaunify check
    // since we hope this can be removed (resulting is better/simpler coordinates) in the future
    //
    // const output = [
    //   [
    //     [1.304, 1.232],
    //     [1, 1],
    //     [1, 2]
    //   ],
    //   [
    //     [1, 2],
    //     [2, 2],
    //     [1.304, 1.232]
    //   ],
    //   [
    //     [1, 1],
    //     [0, 2],
    //     [1, 2]
    //   ],
    //   [
    //     [1, 2],
    //     [0, 2],
    //     [1.304, 2.232]
    //   ],
    //   [
    //     [1.304, 2.232],
    //     [2, 2],
    //     [1, 2]
    //   ],
    //   [
    //     [1.304, 1.232],
    //     [2, 0],
    //     [1, 1]
    //   ],
    //   [
    //     [2, 2],
    //     [2.3040000000000003, 1.232],
    //     [1.304, 1.232]
    //   ],
    //   [
    //     [1.304, 2.232],
    //     [2.3040000000000003, 2.232],
    //     [2, 2]
    //   ],
    //   [
    //     [2, 2],
    //     [3, 2],
    //     [2.3040000000000003, 1.232]
    //   ],
    //   [
    //     [2.3040000000000003, 1.232],
    //     [2, 0],
    //     [1.304, 1.232]
    //   ],
    //   [
    //     [2.3040000000000003, 2.232],
    //     [3, 2],
    //     [2, 2]
    //   ],
    //   [
    //     [2.3040000000000003, 1.232],
    //     [3, 1],
    //     [2, 0]
    //   ]
    // ]

    expectToBeCloseToArrayArrayArray(triangulate([rectangle], 1), output)
  })

  it(`should remove sharp triangles using minimumTriangleAngle`, () => {
    const output = [
      [
        [1.304, 1.232],
        [1.4655588463411926, 0.6034795070965593],
        [0.592, 0.953]
      ],
      [
        [0.592, 0.953],
        [0.3960147328390722, 1.933606840204503],
        [1.304, 1.232]
      ],
      [
        [1.304, 2.232],
        [2.3040000000000003, 1.232],
        [1.304, 1.232]
      ],
      [
        [1.304, 1.232],
        [2.3040000000000003, 1.232],
        [1.4655588463411926, 0.6034795070965593]
      ],
      [
        [0.3960147328390722, 1.933606840204503],
        [1.304, 2.232],
        [1.304, 1.232]
      ],
      [
        [2.3040000000000003, 1.232],
        [2.402519316054499, 0.2648912417868794],
        [1.4655588463411926, 0.6034795070965593]
      ],
      [
        [1.304, 2.232],
        [2.3040000000000003, 2.232],
        [2.3040000000000003, 1.232]
      ],
      [
        [2.3040000000000003, 2.232],
        [2.6532596580272494, 1.2329456208934397],
        [2.3040000000000003, 1.232]
      ],
      [
        [2.3040000000000003, 1.232],
        [2.6532596580272494, 1.2329456208934397],
        [2.402519316054499, 0.2648912417868794]
      ],
      [
        [0.3960147328390722, 1.933606840204503],
        [0.304, 2.394],
        [1.304, 2.232]
      ],
      [
        [2.3040000000000003, 2.232],
        [2.904, 2.201],
        [2.6532596580272494, 1.2329456208934397]
      ]
    ]

    // Keeping trace of the original output before applying the extra delaunify check
    // since we hope this can be removed (resulting is better/simpler coordinates) in the future
    //
    // const output = [
    //   [
    //     [1.304, 1.232],
    //     [1, 1],
    //     [1, 2]
    //   ],
    //   [
    //     [1, 2],
    //     [2, 2],
    //     [1.304, 1.232]
    //   ],
    //   [
    //     [1, 1],
    //     [0, 2],
    //     [1, 2]
    //   ],
    //   [
    //     [1.304, 2.232],
    //     [2, 2],
    //     [1, 2]
    //   ],
    //   [
    //     [1.304, 1.232],
    //     [2, 0],
    //     [1, 1]
    //   ],
    //   [
    //     [2, 2],
    //     [2.3040000000000003, 1.232],
    //     [1.304, 1.232]
    //   ],
    //   [
    //     [1.304, 2.232],
    //     [2.3040000000000003, 2.232],
    //     [2, 2]
    //   ],
    //   [
    //     [2, 2],
    //     [3, 2],
    //     [2.3040000000000003, 1.232]
    //   ],
    //   [
    //     [2.3040000000000003, 1.232],
    //     [2, 0],
    //     [1.304, 1.232]
    //   ],
    //   [
    //     [2.3040000000000003, 2.232],
    //     [3, 2],
    //     [2, 2]
    //   ],
    //   [
    //     [2.3040000000000003, 1.232],
    //     [3, 1],
    //     [2, 0]
    //   ]
    // ]

    expectToBeCloseToArrayArrayArray(
      triangulate([rectangle], 1, { minimumTriangleAngle: 0.2 }),
      output
    )
  })

  it(`should work with rectangles on grid (collinearity check) with no distance provided`, () => {
    const output = [
      [
        [0, 0],
        [0, 2],
        [2, 2]
      ],
      [
        [2, 2],
        [2, 0],
        [0, 0]
      ]
    ]
    expectToBeCloseToArrayArrayArray(triangulate([rectangleOnGrid]), output)
  })

  it(`should work provide the same result when using unique points`, () => {
    const { uniquePointIndexTriangles, uniquePoints } = triangulateToUnique([
      rectangle
    ])
    const triangles = uniquePointIndexTriangles.map((t) =>
      t.map((indexPoint) => uniquePoints[indexPoint])
    )

    const output = [
      [
        [0.592, 0.953],
        [0.304, 2.394],
        [2.904, 2.201]
      ],
      [
        [2.904, 2.201],
        [2.394, 0.232],
        [0.592, 0.953]
      ]
    ]

    expectToBeCloseToArrayArrayArray(triangles, output)
  })
})
